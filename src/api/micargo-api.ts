/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.14.8.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming
//@ts-nocheck

import axios, {
  AxiosError,
  AxiosInstance,
  AxiosRequestConfig,
  AxiosResponse,
  CancelToken,
} from "axios";

export class ActivityClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Получить всех пользователей системы (и админов)
   * @return Success
   */
  activity_GetUsers(cancelToken?: CancelToken | undefined): Promise<GetUsersResponse[]> {
    let url_ = this.baseUrl + "/api/Activity";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processActivity_GetUsers(_response);
      });
  }

  protected processActivity_GetUsers(response: AxiosResponse): Promise<GetUsersResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(GetUsersResponse.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<GetUsersResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetUsersResponse[]>(<any>null);
  }

  /**
   * Получить историю создания всех страховых деклараций
   * @return Success
   */
  activity_GetAllDeclarationHistory(
    cancelToken?: CancelToken | undefined
  ): Promise<GetAllDeclarationHistoryResponse[]> {
    let url_ = this.baseUrl + "/api/Activity/history";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processActivity_GetAllDeclarationHistory(_response);
      });
  }

  protected processActivity_GetAllDeclarationHistory(
    response: AxiosResponse
  ): Promise<GetAllDeclarationHistoryResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200)
          result200!.push(GetAllDeclarationHistoryResponse.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<GetAllDeclarationHistoryResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetAllDeclarationHistoryResponse[]>(<any>null);
  }

  /**
   * Получить историю создания страховых деклараций для конкретного пользователя
   * @return Success
   */
  activity_GetUserDeclarationHistory(
    userId: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDeclarationHistoryResponse[]> {
    let url_ = this.baseUrl + "/api/Activity/history-user{userId}";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processActivity_GetUserDeclarationHistory(_response);
      });
  }

  protected processActivity_GetUserDeclarationHistory(
    response: AxiosResponse
  ): Promise<GetDeclarationHistoryResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(GetDeclarationHistoryResponse.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<GetDeclarationHistoryResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDeclarationHistoryResponse[]>(<any>null);
  }

  /**
   * Получить подробные данные по всем платежам в виде .csv документа
   * @return Success
   */
  activity_DownloadDeclarationHistory(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/Activity/history-csv";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processActivity_DownloadDeclarationHistory(_response);
      });
  }

  protected processActivity_DownloadDeclarationHistory(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Получить подробные данные по всем платежам определённого пользователя в виде .csv документа
   * @return Success
   */
  activity_DownloadDeclarationHistory2(
    userId: number,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Activity/history-csv{userId}";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processActivity_DownloadDeclarationHistory2(_response);
      });
  }

  protected processActivity_DownloadDeclarationHistory2(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Получение декларации по номеру
   * @return Success
   */
  activity_GetDeclaration(
    number: string,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDeclarationResponse> {
    let url_ = this.baseUrl + "/api/Activity/num-declaration{number}";
    if (number === undefined || number === null)
      throw new Error("The parameter 'number' must be defined.");
    url_ = url_.replace("{number}", encodeURIComponent("" + number));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processActivity_GetDeclaration(_response);
      });
  }

  protected processActivity_GetDeclaration(
    response: AxiosResponse
  ): Promise<GetDeclarationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDeclarationResponse.fromJS(resultData200);
      return Promise.resolve<GetDeclarationResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDeclarationResponse>(<any>null);
  }

  /**
   * Получение декларации по Id
   * @return Success
   */
  activity_GetDeclarationById(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDeclarationResponse> {
    let url_ = this.baseUrl + "/api/Activity/declaration{id}";
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processActivity_GetDeclarationById(_response);
      });
  }

  protected processActivity_GetDeclarationById(
    response: AxiosResponse
  ): Promise<GetDeclarationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDeclarationResponse.fromJS(resultData200);
      return Promise.resolve<GetDeclarationResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDeclarationResponse>(<any>null);
  }

  /**
   * Приостановать действие аккаунта и разослать всем админам уведомление об этом
   * @return Success
   */
  activity_SuspendAccount(userId: number, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/Activity/suspend{userId}";
    if (userId === undefined || userId === null)
      throw new Error("The parameter 'userId' must be defined.");
    url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processActivity_SuspendAccount(_response);
      });
  }

  protected processActivity_SuspendAccount(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Связывает конкретную декларацию с выбранной учетной записью
   * @param body (optional)
   * @return Success
   */
  activity_AddToRegister(
    body: AddToRegisterRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Activity/associate";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processActivity_AddToRegister(_response);
      });
  }

  protected processActivity_AddToRegister(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class AuthClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Логин
   * @param body (optional)
   * @return Success
   */
  login(
    body: LoginRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SignInResponse> {
    let url_ = this.baseUrl + "/api/Auth/get-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processLogin(_response);
      });
  }

  protected processLogin(response: AxiosResponse): Promise<SignInResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = SignInResponse.fromJS(resultData200);
      return Promise.resolve<SignInResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SignInResponse>(<any>null);
  }

  /**
   * Получить новый AccessToken
   * @param refreshToken (optional)
   * @return Success
   */
  refreshAccessToken(
    refreshToken: string | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<SignInResponse> {
    let url_ = this.baseUrl + "/api/Auth/refresh-token?";
    if (refreshToken === null) throw new Error("The parameter 'refreshToken' cannot be null.");
    else if (refreshToken !== undefined)
      url_ += "RefreshToken=" + encodeURIComponent("" + refreshToken) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRefreshAccessToken(_response);
      });
  }

  protected processRefreshAccessToken(response: AxiosResponse): Promise<SignInResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = SignInResponse.fromJS(resultData200);
      return Promise.resolve<SignInResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<SignInResponse>(<any>null);
  }

  /**
   * Разлогин
   * @param body (optional)
   * @return Success
   */
  revokeRefreshToken(
    body: TokenRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Auth/revoke-token";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRevokeRefreshToken(_response);
      });
  }

  protected processRevokeRefreshToken(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class DistributionClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Рассылка копий декларации по почте
   * @param body (optional)
   * @return Success
   */
  sendDeclaration(
    body: SendDeclarationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Distribution";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processSendDeclaration(_response);
      });
  }

  protected processSendDeclaration(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class HelloClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Hello
   * @return Success
   */
  hello(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/hello";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processHello(_response);
      });
  }

  protected processHello(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class HomeClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Получить историю создания страховых деклараций
   * @return Success
   */
  getDeclarationsHistory(
    cancelToken?: CancelToken | undefined
  ): Promise<GetDeclarationHistoryResponse[]> {
    let url_ = this.baseUrl + "/api/Home/history";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDeclarationsHistory(_response);
      });
  }

  protected processGetDeclarationsHistory(
    response: AxiosResponse
  ): Promise<GetDeclarationHistoryResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(GetDeclarationHistoryResponse.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<GetDeclarationHistoryResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDeclarationHistoryResponse[]>(<any>null);
  }

  /**
   * Получить историю создания страховых деклараций (для неавторизированного пользователя)
   * @param declarationIds (optional)
   * @return Success
   */
  getDeclarationsHistoryNoauth(
    declarationIds: number[] | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDeclarationHistoryResponse[]> {
    let url_ = this.baseUrl + "/api/Home/noauth/history?";
    if (declarationIds === null) throw new Error("The parameter 'declarationIds' cannot be null.");
    else if (declarationIds !== undefined)
      declarationIds &&
        declarationIds.forEach((item) => {
          url_ += "declarationIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDeclarationsHistoryNoauth(_response);
      });
  }

  protected processGetDeclarationsHistoryNoauth(
    response: AxiosResponse
  ): Promise<GetDeclarationHistoryResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(GetDeclarationHistoryResponse.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<GetDeclarationHistoryResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDeclarationHistoryResponse[]>(<any>null);
  }

  /**
   * Получить подробные данные по всем платежам текущего пользователя в виде .csv документа
   * @return Success
   */
  downloadDeclarationHistory(cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/Home/history-csv";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDownloadDeclarationHistory(_response);
      });
  }

  protected processDownloadDeclarationHistory(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Получить подробные данные по платежам неавторизированного пользователя в виде .csv документа
   * @param declarationIds (optional)
   * @return Success
   */
  downloadDeclarationHistoryNoauth(
    declarationIds: number[] | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Home/noauth/history-csv?";
    if (declarationIds === null) throw new Error("The parameter 'declarationIds' cannot be null.");
    else if (declarationIds !== undefined)
      declarationIds &&
        declarationIds.forEach((item) => {
          url_ += "declarationIds=" + encodeURIComponent("" + item) + "&";
        });
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processDownloadDeclarationHistoryNoauth(_response);
      });
  }

  protected processDownloadDeclarationHistoryNoauth(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Получение декларации по номеру
   * @return Success
   */
  getDeclarationByNumber(
    number: string,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDeclarationResponse> {
    let url_ = this.baseUrl + "/api/Home/num-declaration{number}";
    if (number === undefined || number === null)
      throw new Error("The parameter 'number' must be defined.");
    url_ = url_.replace("{number}", encodeURIComponent("" + number));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDeclarationByNumber(_response);
      });
  }

  protected processGetDeclarationByNumber(
    response: AxiosResponse
  ): Promise<GetDeclarationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDeclarationResponse.fromJS(resultData200);
      return Promise.resolve<GetDeclarationResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDeclarationResponse>(<any>null);
  }

  /**
   * Получение декларации по Id
   * @return Success
   */
  getDeclarationById(
    id: number,
    cancelToken?: CancelToken | undefined
  ): Promise<GetDeclarationResponse> {
    let url_ = this.baseUrl + "/api/Home/declaration{id}";
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetDeclarationById(_response);
      });
  }

  protected processGetDeclarationById(response: AxiosResponse): Promise<GetDeclarationResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetDeclarationResponse.fromJS(resultData200);
      return Promise.resolve<GetDeclarationResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetDeclarationResponse>(<any>null);
  }

  /**
   * Подать жалобу
   * @param body (optional)
   * @return Success
   */
  fileAClaim(
    body: FileAClaimRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Home/claim";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processFileAClaim(_response);
      });
  }

  protected processFileAClaim(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Отмена покрытия (Заявка на возврат средств)
   * @param body (optional)
   * @return Success
   */
  cancelCoverage(
    body: CancelCoverageRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Home/cancel-coverage";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCancelCoverage(_response);
      });
  }

  protected processCancelCoverage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class PaymentClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Произвести оплату картой
   * @param body (optional)
   * @return Success
   */
  chargeCard(
    body: ChargeCardRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Payment/pay";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processChargeCard(_response);
      });
  }

  protected processChargeCard(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Инициирует обратный платёж клиенту, который захотел вернуть средства за декларацию
   * @return Success
   */
  refundCoverage(declarationId: number, cancelToken?: CancelToken | undefined): Promise<void> {
    let url_ = this.baseUrl + "/api/Payment/refund{declarationId}";
    if (declarationId === undefined || declarationId === null)
      throw new Error("The parameter 'declarationId' must be defined.");
    url_ = url_.replace("{declarationId}", encodeURIComponent("" + declarationId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "PUT",
      url: url_,
      headers: {},
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processRefundCoverage(_response);
      });
  }

  protected processRefundCoverage(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class ProfileClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Регистрация нового пользователя
   * @param body (optional)
   * @return Success
   */
  createUser(
    body: CreateUserRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Profile";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateUser(_response);
      });
  }

  protected processCreateUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Редактирование данных текущего пользователя
   * @param body (optional)
   * @return Success
   */
  updateCurrentUser(
    body: UpdateCurrentUserRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Profile";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateCurrentUser(_response);
      });
  }

  protected processUpdateCurrentUser(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Получить данные текущего пользователя
   * @return Success
   */
  getCurrentUser(cancelToken?: CancelToken | undefined): Promise<GetCurrentUserResponse> {
    let url_ = this.baseUrl + "/api/Profile";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetCurrentUser(_response);
      });
  }

  protected processGetCurrentUser(response: AxiosResponse): Promise<GetCurrentUserResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetCurrentUserResponse.fromJS(resultData200);
      return Promise.resolve<GetCurrentUserResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetCurrentUserResponse>(<any>null);
  }

  /**
   * Получение Id пользователей по первым буквам businessName
   * @return Success
   */
  getUserByBusinessName(
    businessName: string,
    cancelToken?: CancelToken | undefined
  ): Promise<GetUserByBusinessNameResponse[]> {
    // let url_ = this.baseUrl + "/api/Profile/admin/sameUsers{businessName}";
    let url_ = this.baseUrl + "/api/Profile/admin/sameUsers/bn{businessName}";
    if (businessName === undefined || businessName === null)
      throw new Error("The parameter 'businessName' must be defined.");
    url_ = url_.replace("{businessName}", encodeURIComponent("" + businessName));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserByBusinessName(_response);
      });
  }

  protected processGetUserByBusinessName(
    response: AxiosResponse
  ): Promise<GetUserByBusinessNameResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(GetUserByBusinessNameResponse.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<GetUserByBusinessNameResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetUserByBusinessNameResponse[]>(<any>null);
  }

  /**
   * Создание нового админа или пользователя
   * @param body (optional)
   * @return Success
   */
  createUserOrAdmin(
    body: CreateUserAdminRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Profile/admin";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateUserOrAdmin(_response);
      });
  }

  protected processCreateUserOrAdmin(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Редактирование данных пользователя или админа
   * @param body (optional)
   * @return Success
   */
  updateUserOrAdmin(
    body: UpdateAdminRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Profile/admin";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "PUT",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processUpdateUserOrAdmin(_response);
      });
  }

  protected processUpdateUserOrAdmin(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Получение данных пользователя или админа
   * @return Success
   */
  getUserOrAdmin(id: number, cancelToken?: CancelToken | undefined): Promise<GetUserResponse> {
    let url_ = this.baseUrl + "/api/Profile/admin{id}";
    if (id === undefined || id === null) throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetUserOrAdmin(_response);
      });
  }

  protected processGetUserOrAdmin(response: AxiosResponse): Promise<GetUserResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = GetUserResponse.fromJS(resultData200);
      return Promise.resolve<GetUserResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetUserResponse>(<any>null);
  }
}

export class QuoteClient {
  private instance: AxiosInstance;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(baseUrl?: string, instance?: AxiosInstance) {
    this.instance = instance ? instance : axios.create();
    this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
  }

  /**
   * Получить список допустимых товаров (только для целей разработки)
   * @return Success
   */
  getInsuredCargos(cancelToken?: CancelToken | undefined): Promise<GetInsuredCargosResponse[]> {
    let url_ = this.baseUrl + "/api/Quote/cargo-list";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetInsuredCargos(_response);
      });
  }

  protected processGetInsuredCargos(response: AxiosResponse): Promise<GetInsuredCargosResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(GetInsuredCargosResponse.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<GetInsuredCargosResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetInsuredCargosResponse[]>(<any>null);
  }

  /**
   * Получить список типов грузовых автомобилей (только для целей разработки)
   * @return Success
   */
  getTrailerTypes(cancelToken?: CancelToken | undefined): Promise<GetTrailerTypesResponse[]> {
    let url_ = this.baseUrl + "/api/Quote/trailer-list";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetTrailerTypes(_response);
      });
  }

  protected processGetTrailerTypes(response: AxiosResponse): Promise<GetTrailerTypesResponse[]> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      if (Array.isArray(resultData200)) {
        result200 = [] as any;
        for (let item of resultData200) result200!.push(GetTrailerTypesResponse.fromJS(item));
      } else {
        result200 = <any>null;
      }
      return Promise.resolve<GetTrailerTypesResponse[]>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<GetTrailerTypesResponse[]>(<any>null);
  }

  /**
   * Получить адреса населённых пунктов по почтовому индексу
   * @param zipCode (optional)
   * @param country (optional)
   * @return Success
   */
  getZipCode(
    zipCode: string | undefined,
    country: string | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<ZipCodeResponse> {
    let url_ = this.baseUrl + "/api/Quote/zipCode";
    url_ = url_.replace(/[?&]$/, "");

    let options_ = <AxiosRequestConfig>{
      method: "GET",
      url: url_,
      headers: {
        zipCode: zipCode !== undefined && zipCode !== null ? "" + zipCode : "",
        country: country !== undefined && country !== null ? "" + country : "",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processGetZipCode(_response);
      });
  }

  protected processGetZipCode(response: AxiosResponse): Promise<ZipCodeResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = ZipCodeResponse.fromJS(resultData200);
      return Promise.resolve<ZipCodeResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<ZipCodeResponse>(<any>null);
  }

  /**
   * Подсчитать стоимость страховки и записать расчёты в базу данных
   * @param body (optional)
   * @return Success
   */
  createQuoteWithDeclaration(
    body: QuoteRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<QuoteResponse> {
    let url_ = this.baseUrl + "/api/Quote";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
        Accept: "text/plain",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processCreateQuoteWithDeclaration(_response);
      });
  }

  protected processCreateQuoteWithDeclaration(response: AxiosResponse): Promise<QuoteResponse> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      let result200: any = null;
      let resultData200 = _responseText;
      result200 = QuoteResponse.fromJS(resultData200);
      return Promise.resolve<QuoteResponse>(result200);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<QuoteResponse>(<any>null);
  }

  /**
   * Проверка информации о доставке и добавление её к страховой декларации
   * @param body (optional)
   * @return Success
   */
  addShippingInformation(
    body: ShippingInformationRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Quote/ship";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddShippingInformation(_response);
      });
  }

  protected processAddShippingInformation(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }

  /**
   * Проверка информации о перевозчике и добавление её к страховой декларации
   * @param body (optional)
   * @return Success
   */
  addCarrierDetail(
    body: CarrierDetailRequest | undefined,
    cancelToken?: CancelToken | undefined
  ): Promise<void> {
    let url_ = this.baseUrl + "/api/Quote/carrier";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(body);

    let options_ = <AxiosRequestConfig>{
      data: content_,
      method: "POST",
      url: url_,
      headers: {
        "Content-Type": "application/json",
      },
      cancelToken,
    };

    return this.instance
      .request(options_)
      .catch((_error: any) => {
        if (isAxiosError(_error) && _error.response) {
          return _error.response;
        } else {
          throw _error;
        }
      })
      .then((_response: AxiosResponse) => {
        return this.processAddCarrierDetail(_response);
      });
  }

  protected processAddCarrierDetail(response: AxiosResponse): Promise<void> {
    const status = response.status;
    let _headers: any = {};
    if (response.headers && typeof response.headers === "object") {
      for (let k in response.headers) {
        if (response.headers.hasOwnProperty(k)) {
          _headers[k] = response.headers[k];
        }
      }
    }
    if (status === 200) {
      const _responseText = response.data;
      return Promise.resolve<void>(<any>null);
    } else if (status !== 200 && status !== 204) {
      const _responseText = response.data;
      return throwException(
        "An unexpected server error occurred.",
        status,
        _responseText,
        _headers
      );
    }
    return Promise.resolve<void>(<any>null);
  }
}

export class AddToRegisterRequest implements IAddToRegisterRequest {
  declarationId?: number;
  userId?: number;

  constructor(data?: IAddToRegisterRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationId = _data["declarationId"];
      this.userId = _data["userId"];
    }
  }

  static fromJS(data: any): AddToRegisterRequest {
    data = typeof data === "object" ? data : {};
    let result = new AddToRegisterRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationId"] = this.declarationId;
    data["userId"] = this.userId;
    return data;
  }
}

export interface IAddToRegisterRequest {
  declarationId?: number;
  userId?: number;
}

export class CancelCoverageRequest implements ICancelCoverageRequest {
  declarationId?: number;
  purchaserName?: string | undefined;

  constructor(data?: ICancelCoverageRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationId = _data["declarationId"];
      this.purchaserName = _data["purchaserName"];
    }
  }

  static fromJS(data: any): CancelCoverageRequest {
    data = typeof data === "object" ? data : {};
    let result = new CancelCoverageRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationId"] = this.declarationId;
    data["purchaserName"] = this.purchaserName;
    return data;
  }
}

export interface ICancelCoverageRequest {
  declarationId?: number;
  purchaserName?: string | undefined;
}

export class CarrierDetailRequest implements ICarrierDetailRequest {
  insuranceDeclarationId?: number;
  doT_Number?: string | undefined;
  motor_Carrier_Name?: string | undefined;
  physical_Address?: string | undefined;
  mailing_Address?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip_Code?: string | undefined;
  country?: string | undefined;

  constructor(data?: ICarrierDetailRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.insuranceDeclarationId = _data["insuranceDeclarationId"];
      this.doT_Number = _data["doT_Number"];
      this.motor_Carrier_Name = _data["motor_Carrier_Name"];
      this.physical_Address = _data["physical_Address"];
      this.mailing_Address = _data["mailing_Address"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.zip_Code = _data["zip_Code"];
      this.country = _data["country"];
    }
  }

  static fromJS(data: any): CarrierDetailRequest {
    data = typeof data === "object" ? data : {};
    let result = new CarrierDetailRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["insuranceDeclarationId"] = this.insuranceDeclarationId;
    data["doT_Number"] = this.doT_Number;
    data["motor_Carrier_Name"] = this.motor_Carrier_Name;
    data["physical_Address"] = this.physical_Address;
    data["mailing_Address"] = this.mailing_Address;
    data["city"] = this.city;
    data["state"] = this.state;
    data["zip_Code"] = this.zip_Code;
    data["country"] = this.country;
    return data;
  }
}

export interface ICarrierDetailRequest {
  insuranceDeclarationId?: number;
  doT_Number?: string | undefined;
  motor_Carrier_Name?: string | undefined;
  physical_Address?: string | undefined;
  mailing_Address?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip_Code?: string | undefined;
  country?: string | undefined;
}

export class ChargeCardRequest implements IChargeCardRequest {
  declarationId?: number;
  purchaserName?: string | undefined;
  purchaserRole?: string | undefined;
  cardNumber?: string | undefined;
  expirationDate?: string | undefined;
  cardCode?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  country?: string | undefined;
  zip?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  phoneNumber?: string | undefined;
  email?: string | undefined;

  constructor(data?: IChargeCardRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationId = _data["declarationId"];
      this.purchaserName = _data["purchaserName"];
      this.purchaserRole = _data["purchaserRole"];
      this.cardNumber = _data["cardNumber"];
      this.expirationDate = _data["expirationDate"];
      this.cardCode = _data["cardCode"];
      this.firstName = _data["firstName"];
      this.lastName = _data["lastName"];
      this.country = _data["country"];
      this.zip = _data["zip"];
      this.address = _data["address"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.phoneNumber = _data["phoneNumber"];
      this.email = _data["email"];
    }
  }

  static fromJS(data: any): ChargeCardRequest {
    data = typeof data === "object" ? data : {};
    let result = new ChargeCardRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationId"] = this.declarationId;
    data["purchaserName"] = this.purchaserName;
    data["purchaserRole"] = this.purchaserRole;
    data["cardNumber"] = this.cardNumber;
    data["expirationDate"] = this.expirationDate;
    data["cardCode"] = this.cardCode;
    data["firstName"] = this.firstName;
    data["lastName"] = this.lastName;
    data["country"] = this.country;
    data["zip"] = this.zip;
    data["address"] = this.address;
    data["city"] = this.city;
    data["state"] = this.state;
    data["phoneNumber"] = this.phoneNumber;
    data["email"] = this.email;
    return data;
  }
}

export interface IChargeCardRequest {
  declarationId?: number;
  purchaserName?: string | undefined;
  purchaserRole?: string | undefined;
  cardNumber?: string | undefined;
  expirationDate?: string | undefined;
  cardCode?: string | undefined;
  firstName?: string | undefined;
  lastName?: string | undefined;
  country?: string | undefined;
  zip?: string | undefined;
  address?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  phoneNumber?: string | undefined;
  email?: string | undefined;
}

export class CreateUserAdminRequest implements ICreateUserAdminRequest {
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAdmin?: boolean;

  constructor(data?: ICreateUserAdminRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.business_Name = _data["business_Name"];
      this.mailing_Address_1 = _data["mailing_Address_1"];
      this.mailing_Address_2 = _data["mailing_Address_2"];
      this.country = _data["country"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.zip = _data["zip"];
      this.contact_Name = _data["contact_Name"];
      this.contact_Email = _data["contact_Email"];
      this.username = _data["username"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.isAdmin = _data["isAdmin"];
    }
  }

  static fromJS(data: any): CreateUserAdminRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateUserAdminRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["business_Name"] = this.business_Name;
    data["mailing_Address_1"] = this.mailing_Address_1;
    data["mailing_Address_2"] = this.mailing_Address_2;
    data["country"] = this.country;
    data["city"] = this.city;
    data["state"] = this.state;
    data["zip"] = this.zip;
    data["contact_Name"] = this.contact_Name;
    data["contact_Email"] = this.contact_Email;
    data["username"] = this.username;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["isAdmin"] = this.isAdmin;
    return data;
  }
}

export interface ICreateUserAdminRequest {
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAdmin?: boolean;
}

export class CreateUserRequest implements ICreateUserRequest {
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: ICreateUserRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.business_Name = _data["business_Name"];
      this.mailing_Address_1 = _data["mailing_Address_1"];
      this.mailing_Address_2 = _data["mailing_Address_2"];
      this.country = _data["country"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.zip = _data["zip"];
      this.contact_Name = _data["contact_Name"];
      this.contact_Email = _data["contact_Email"];
      this.username = _data["username"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
    }
  }

  static fromJS(data: any): CreateUserRequest {
    data = typeof data === "object" ? data : {};
    let result = new CreateUserRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["business_Name"] = this.business_Name;
    data["mailing_Address_1"] = this.mailing_Address_1;
    data["mailing_Address_2"] = this.mailing_Address_2;
    data["country"] = this.country;
    data["city"] = this.city;
    data["state"] = this.state;
    data["zip"] = this.zip;
    data["contact_Name"] = this.contact_Name;
    data["contact_Email"] = this.contact_Email;
    data["username"] = this.username;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    return data;
  }
}

export interface ICreateUserRequest {
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
}

export class FileAClaimRequest implements IFileAClaimRequest {
  declarationId?: number;
  claimantName?: string | undefined;
  claimantContactInformation?: string | undefined;
  descriptionOfLoss?: string | undefined;

  constructor(data?: IFileAClaimRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationId = _data["declarationId"];
      this.claimantName = _data["claimantName"];
      this.claimantContactInformation = _data["claimantContactInformation"];
      this.descriptionOfLoss = _data["descriptionOfLoss"];
    }
  }

  static fromJS(data: any): FileAClaimRequest {
    data = typeof data === "object" ? data : {};
    let result = new FileAClaimRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationId"] = this.declarationId;
    data["claimantName"] = this.claimantName;
    data["claimantContactInformation"] = this.claimantContactInformation;
    data["descriptionOfLoss"] = this.descriptionOfLoss;
    return data;
  }
}

export interface IFileAClaimRequest {
  declarationId?: number;
  claimantName?: string | undefined;
  claimantContactInformation?: string | undefined;
  descriptionOfLoss?: string | undefined;
}

export class GetAllDeclarationHistoryResponse implements IGetAllDeclarationHistoryResponse {
  id?: number;
  number?: string | undefined;
  businessName?: string | undefined;
  purchaseDate?: Date;
  status?: string | undefined;
  amount?: number;

  constructor(data?: IGetAllDeclarationHistoryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.number = _data["number"];
      this.businessName = _data["businessName"];
      this.purchaseDate = _data["purchaseDate"]
        ? new Date(_data["purchaseDate"].toString())
        : <any>undefined;
      this.status = _data["status"];
      this.amount = _data["amount"];
    }
  }

  static fromJS(data: any): GetAllDeclarationHistoryResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetAllDeclarationHistoryResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["number"] = this.number;
    data["businessName"] = this.businessName;
    data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
    data["status"] = this.status;
    data["amount"] = this.amount;
    return data;
  }
}

export interface IGetAllDeclarationHistoryResponse {
  id?: number;
  number?: string | undefined;
  businessName?: string | undefined;
  purchaseDate?: Date;
  status?: string | undefined;
  amount?: number;
}

export class GetCurrentUserResponse implements IGetCurrentUserResponse {
  id?: number;
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;

  constructor(data?: IGetCurrentUserResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.business_Name = _data["business_Name"];
      this.mailing_Address_1 = _data["mailing_Address_1"];
      this.mailing_Address_2 = _data["mailing_Address_2"];
      this.country = _data["country"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.zip = _data["zip"];
      this.contact_Name = _data["contact_Name"];
      this.contact_Email = _data["contact_Email"];
      this.username = _data["username"];
    }
  }

  static fromJS(data: any): GetCurrentUserResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetCurrentUserResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["business_Name"] = this.business_Name;
    data["mailing_Address_1"] = this.mailing_Address_1;
    data["mailing_Address_2"] = this.mailing_Address_2;
    data["country"] = this.country;
    data["city"] = this.city;
    data["state"] = this.state;
    data["zip"] = this.zip;
    data["contact_Name"] = this.contact_Name;
    data["contact_Email"] = this.contact_Email;
    data["username"] = this.username;
    return data;
  }
}

export interface IGetCurrentUserResponse {
  id?: number;
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
}

export class GetDeclarationHistoryResponse implements IGetDeclarationHistoryResponse {
  id?: number;
  number?: string | undefined;
  purchaseDate?: Date;
  status?: string | undefined;
  amount?: number;

  constructor(data?: IGetDeclarationHistoryResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.number = _data["number"];
      this.purchaseDate = _data["purchaseDate"]
        ? new Date(_data["purchaseDate"].toString())
        : <any>undefined;
      this.status = _data["status"];
      this.amount = _data["amount"];
    }
  }

  static fromJS(data: any): GetDeclarationHistoryResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetDeclarationHistoryResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["number"] = this.number;
    data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
    data["status"] = this.status;
    data["amount"] = this.amount;
    return data;
  }
}

export interface IGetDeclarationHistoryResponse {
  id?: number;
  number?: string | undefined;
  purchaseDate?: Date;
  status?: string | undefined;
  amount?: number;
}

export class GetDeclarationResponse implements IGetDeclarationResponse {
  id?: number;
  number?: string | undefined;
  purchaseDate?: Date;
  status?: string | undefined;
  amount?: number;
  distance?: number;
  insuredCargoName?: string | undefined;
  cargoValue?: number;
  deductible?: number;
  fullValue?: number;
  origin?: string | undefined;
  destination?: string | undefined;
  fromZipCode?: string | undefined;
  toZipCode?: string | undefined;
  pickUp?: Date;
  delivery?: Date;
  bol?: string | undefined;
  dot?: string | undefined;
  motorCarrierName?: string | undefined;

  constructor(data?: IGetDeclarationResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.number = _data["number"];
      this.purchaseDate = _data["purchaseDate"]
        ? new Date(_data["purchaseDate"].toString())
        : <any>undefined;
      this.status = _data["status"];
      this.amount = _data["amount"];
      this.distance = _data["distance"];
      this.insuredCargoName = _data["insuredCargoName"];
      this.cargoValue = _data["cargoValue"];
      this.deductible = _data["deductible"];
      this.fullValue = _data["fullValue"];
      this.origin = _data["origin"];
      this.destination = _data["destination"];
      this.fromZipCode = _data["fromZipCode"];
      this.toZipCode = _data["toZipCode"];
      this.pickUp = _data["pickUp"] ? new Date(_data["pickUp"].toString()) : <any>undefined;
      this.delivery = _data["delivery"] ? new Date(_data["delivery"].toString()) : <any>undefined;
      this.bol = _data["bol"];
      this.dot = _data["dot"];
      this.motorCarrierName = _data["motorCarrierName"];
    }
  }

  static fromJS(data: any): GetDeclarationResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetDeclarationResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["number"] = this.number;
    data["purchaseDate"] = this.purchaseDate ? this.purchaseDate.toISOString() : <any>undefined;
    data["status"] = this.status;
    data["amount"] = this.amount;
    data["distance"] = this.distance;
    data["insuredCargoName"] = this.insuredCargoName;
    data["cargoValue"] = this.cargoValue;
    data["deductible"] = this.deductible;
    data["fullValue"] = this.fullValue;
    data["origin"] = this.origin;
    data["destination"] = this.destination;
    data["fromZipCode"] = this.fromZipCode;
    data["toZipCode"] = this.toZipCode;
    data["pickUp"] = this.pickUp ? this.pickUp.toISOString() : <any>undefined;
    data["delivery"] = this.delivery ? this.delivery.toISOString() : <any>undefined;
    data["bol"] = this.bol;
    data["dot"] = this.dot;
    data["motorCarrierName"] = this.motorCarrierName;
    return data;
  }
}

export interface IGetDeclarationResponse {
  id?: number;
  number?: string | undefined;
  purchaseDate?: Date;
  status?: string | undefined;
  amount?: number;
  distance?: number;
  insuredCargoName?: string | undefined;
  cargoValue?: number;
  deductible?: number;
  fullValue?: number;
  origin?: string | undefined;
  destination?: string | undefined;
  fromZipCode?: string | undefined;
  toZipCode?: string | undefined;
  pickUp?: Date;
  delivery?: Date;
  bol?: string | undefined;
  dot?: string | undefined;
  motorCarrierName?: string | undefined;
}

export class GetInsuredCargosResponse implements IGetInsuredCargosResponse {
  id?: number;
  name?: string | undefined;

  constructor(data?: IGetInsuredCargosResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): GetInsuredCargosResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetInsuredCargosResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    return data;
  }
}

export interface IGetInsuredCargosResponse {
  id?: number;
  name?: string | undefined;
}

export class GetTrailerTypesResponse implements IGetTrailerTypesResponse {
  id?: number;
  name?: string | undefined;

  constructor(data?: IGetTrailerTypesResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
    }
  }

  static fromJS(data: any): GetTrailerTypesResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetTrailerTypesResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    return data;
  }
}

export interface IGetTrailerTypesResponse {
  id?: number;
  name?: string | undefined;
}

export class GetUserByBusinessNameResponse implements IGetUserByBusinessNameResponse {
  id?: number;
  businessName?: string | undefined;

  constructor(data?: IGetUserByBusinessNameResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.businessName = _data["businessName"];
    }
  }

  static fromJS(data: any): GetUserByBusinessNameResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetUserByBusinessNameResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["businessName"] = this.businessName;
    return data;
  }
}

export interface IGetUserByBusinessNameResponse {
  id?: number;
  businessName?: string | undefined;
}

export class GetUserResponse implements IGetUserResponse {
  id?: number;
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  isAdmin?: boolean;

  constructor(data?: IGetUserResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.business_Name = _data["business_Name"];
      this.mailing_Address_1 = _data["mailing_Address_1"];
      this.mailing_Address_2 = _data["mailing_Address_2"];
      this.country = _data["country"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.zip = _data["zip"];
      this.contact_Name = _data["contact_Name"];
      this.contact_Email = _data["contact_Email"];
      this.username = _data["username"];
      this.isAdmin = _data["isAdmin"];
    }
  }

  static fromJS(data: any): GetUserResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetUserResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["business_Name"] = this.business_Name;
    data["mailing_Address_1"] = this.mailing_Address_1;
    data["mailing_Address_2"] = this.mailing_Address_2;
    data["country"] = this.country;
    data["city"] = this.city;
    data["state"] = this.state;
    data["zip"] = this.zip;
    data["contact_Name"] = this.contact_Name;
    data["contact_Email"] = this.contact_Email;
    data["username"] = this.username;
    data["isAdmin"] = this.isAdmin;
    return data;
  }
}

export interface IGetUserResponse {
  id?: number;
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  isAdmin?: boolean;
}

export class GetUsersResponse implements IGetUsersResponse {
  id?: number;
  business_Name?: string | undefined;
  isSuspended?: boolean;
  isAdmin?: boolean;

  constructor(data?: IGetUsersResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.business_Name = _data["business_Name"];
      this.isSuspended = _data["isSuspended"];
      this.isAdmin = _data["isAdmin"];
    }
  }

  static fromJS(data: any): GetUsersResponse {
    data = typeof data === "object" ? data : {};
    let result = new GetUsersResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["business_Name"] = this.business_Name;
    data["isSuspended"] = this.isSuspended;
    data["isAdmin"] = this.isAdmin;
    return data;
  }
}

export interface IGetUsersResponse {
  id?: number;
  business_Name?: string | undefined;
  isSuspended?: boolean;
  isAdmin?: boolean;
}

export class LoginRequest implements ILoginRequest {
  username?: string | undefined;
  password?: string | undefined;

  constructor(data?: ILoginRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.username = _data["username"];
      this.password = _data["password"];
    }
  }

  static fromJS(data: any): LoginRequest {
    data = typeof data === "object" ? data : {};
    let result = new LoginRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["username"] = this.username;
    data["password"] = this.password;
    return data;
  }
}

export interface ILoginRequest {
  username?: string | undefined;
  password?: string | undefined;
}

export class QuoteRequest implements IQuoteRequest {
  insuredCargoId?: number;
  fullValue?: number;
  trailerTypeId?: number;
  fromZipCode?: string | undefined;
  fromAddress?: string | undefined;
  toZipCode?: string | undefined;
  toAddress?: string | undefined;

  constructor(data?: IQuoteRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.insuredCargoId = _data["insuredCargoId"];
      this.fullValue = _data["fullValue"];
      this.trailerTypeId = _data["trailerTypeId"];
      this.fromZipCode = _data["fromZipCode"];
      this.fromAddress = _data["fromAddress"];
      this.toZipCode = _data["toZipCode"];
      this.toAddress = _data["toAddress"];
    }
  }

  static fromJS(data: any): QuoteRequest {
    data = typeof data === "object" ? data : {};
    let result = new QuoteRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["insuredCargoId"] = this.insuredCargoId;
    data["fullValue"] = this.fullValue;
    data["trailerTypeId"] = this.trailerTypeId;
    data["fromZipCode"] = this.fromZipCode;
    data["fromAddress"] = this.fromAddress;
    data["toZipCode"] = this.toZipCode;
    data["toAddress"] = this.toAddress;
    return data;
  }
}

export interface IQuoteRequest {
  insuredCargoId?: number;
  fullValue?: number;
  trailerTypeId?: number;
  fromZipCode?: string | undefined;
  fromAddress?: string | undefined;
  toZipCode?: string | undefined;
  toAddress?: string | undefined;
}

export class QuoteResponse implements IQuoteResponse {
  declarationId?: number;
  declarationNumber?: string | undefined;
  amount?: number;
  distance?: number;
  deductible?: number;

  constructor(data?: IQuoteResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationId = _data["declarationId"];
      this.declarationNumber = _data["declarationNumber"];
      this.amount = _data["amount"];
      this.distance = _data["distance"];
      this.deductible = _data["deductible"];
    }
  }

  static fromJS(data: any): QuoteResponse {
    data = typeof data === "object" ? data : {};
    let result = new QuoteResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationId"] = this.declarationId;
    data["declarationNumber"] = this.declarationNumber;
    data["amount"] = this.amount;
    data["distance"] = this.distance;
    data["deductible"] = this.deductible;
    return data;
  }
}

export interface IQuoteResponse {
  declarationId?: number;
  declarationNumber?: string | undefined;
  amount?: number;
  distance?: number;
  deductible?: number;
}

export class SendDeclarationRequest implements ISendDeclarationRequest {
  declarationId?: number;
  emails?: string[] | undefined;

  constructor(data?: ISendDeclarationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.declarationId = _data["declarationId"];
      if (Array.isArray(_data["emails"])) {
        this.emails = [] as any;
        for (let item of _data["emails"]) this.emails!.push(item);
      }
    }
  }

  static fromJS(data: any): SendDeclarationRequest {
    data = typeof data === "object" ? data : {};
    let result = new SendDeclarationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["declarationId"] = this.declarationId;
    if (Array.isArray(this.emails)) {
      data["emails"] = [];
      for (let item of this.emails) data["emails"].push(item);
    }
    return data;
  }
}

export interface ISendDeclarationRequest {
  declarationId?: number;
  emails?: string[] | undefined;
}

export class ShippingInformationRequest implements IShippingInformationRequest {
  insuranceDeclarationId?: number;
  pick_up_Date?: Date;
  delivery_Date?: Date;
  boL_Number?: string | undefined;
  shipper_Name?: string | undefined;
  shipper_Email?: string | undefined;
  shipper_Address?: string | undefined;
  shipper_Country?: string | undefined;
  shipper_City?: string | undefined;
  shipper_State?: string | undefined;
  shipper_Zip?: string | undefined;
  carrier_Contact_Name?: string | undefined;
  carrier_Contact_Phone?: string | undefined;
  carrier_Contact_Email?: string | undefined;
  consignee_Name?: string | undefined;
  consignee_Email?: string | undefined;
  broker_Name?: string | undefined;
  broker_Email?: string | undefined;

  constructor(data?: IShippingInformationRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.insuranceDeclarationId = _data["insuranceDeclarationId"];
      this.pick_up_Date = _data["pick_up_Date"]
        ? new Date(_data["pick_up_Date"].toString())
        : <any>undefined;
      this.delivery_Date = _data["delivery_Date"]
        ? new Date(_data["delivery_Date"].toString())
        : <any>undefined;
      this.boL_Number = _data["boL_Number"];
      this.shipper_Name = _data["shipper_Name"];
      this.shipper_Email = _data["shipper_Email"];
      this.shipper_Address = _data["shipper_Address"];
      this.shipper_Country = _data["shipper_Country"];
      this.shipper_City = _data["shipper_City"];
      this.shipper_State = _data["shipper_State"];
      this.shipper_Zip = _data["shipper_Zip"];
      this.carrier_Contact_Name = _data["carrier_Contact_Name"];
      this.carrier_Contact_Phone = _data["carrier_Contact_Phone"];
      this.carrier_Contact_Email = _data["carrier_Contact_Email"];
      this.consignee_Name = _data["consignee_Name"];
      this.consignee_Email = _data["consignee_Email"];
      this.broker_Name = _data["broker_Name"];
      this.broker_Email = _data["broker_Email"];
    }
  }

  static fromJS(data: any): ShippingInformationRequest {
    data = typeof data === "object" ? data : {};
    let result = new ShippingInformationRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["insuranceDeclarationId"] = this.insuranceDeclarationId;
    data["pick_up_Date"] = this.pick_up_Date ? this.pick_up_Date.toISOString() : <any>undefined;
    data["delivery_Date"] = this.delivery_Date ? this.delivery_Date.toISOString() : <any>undefined;
    data["boL_Number"] = this.boL_Number;
    data["shipper_Name"] = this.shipper_Name;
    data["shipper_Email"] = this.shipper_Email;
    data["shipper_Address"] = this.shipper_Address;
    data["shipper_Country"] = this.shipper_Country;
    data["shipper_City"] = this.shipper_City;
    data["shipper_State"] = this.shipper_State;
    data["shipper_Zip"] = this.shipper_Zip;
    data["carrier_Contact_Name"] = this.carrier_Contact_Name;
    data["carrier_Contact_Phone"] = this.carrier_Contact_Phone;
    data["carrier_Contact_Email"] = this.carrier_Contact_Email;
    data["consignee_Name"] = this.consignee_Name;
    data["consignee_Email"] = this.consignee_Email;
    data["broker_Name"] = this.broker_Name;
    data["broker_Email"] = this.broker_Email;
    return data;
  }
}

export interface IShippingInformationRequest {
  insuranceDeclarationId?: number;
  pick_up_Date?: Date;
  delivery_Date?: Date;
  boL_Number?: string | undefined;
  shipper_Name?: string | undefined;
  shipper_Email?: string | undefined;
  shipper_Address?: string | undefined;
  shipper_Country?: string | undefined;
  shipper_City?: string | undefined;
  shipper_State?: string | undefined;
  shipper_Zip?: string | undefined;
  carrier_Contact_Name?: string | undefined;
  carrier_Contact_Phone?: string | undefined;
  carrier_Contact_Email?: string | undefined;
  consignee_Name?: string | undefined;
  consignee_Email?: string | undefined;
  broker_Name?: string | undefined;
  broker_Email?: string | undefined;
}

export class SignInResponse implements ISignInResponse {
  accessToken?: string | undefined;
  refreshToken?: string | undefined;

  constructor(data?: ISignInResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.accessToken = _data["accessToken"];
      this.refreshToken = _data["refreshToken"];
    }
  }

  static fromJS(data: any): SignInResponse {
    data = typeof data === "object" ? data : {};
    let result = new SignInResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["accessToken"] = this.accessToken;
    data["refreshToken"] = this.refreshToken;
    return data;
  }
}

export interface ISignInResponse {
  accessToken?: string | undefined;
  refreshToken?: string | undefined;
}

export class TokenRequest implements ITokenRequest {
  refreshToken?: string | undefined;

  constructor(data?: ITokenRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.refreshToken = _data["refreshToken"];
    }
  }

  static fromJS(data: any): TokenRequest {
    data = typeof data === "object" ? data : {};
    let result = new TokenRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["refreshToken"] = this.refreshToken;
    return data;
  }
}

export interface ITokenRequest {
  refreshToken?: string | undefined;
}

export class UpdateAdminRequest implements IUpdateAdminRequest {
  id?: number;
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAdmin?: boolean;

  constructor(data?: IUpdateAdminRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.business_Name = _data["business_Name"];
      this.mailing_Address_1 = _data["mailing_Address_1"];
      this.mailing_Address_2 = _data["mailing_Address_2"];
      this.country = _data["country"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.zip = _data["zip"];
      this.contact_Name = _data["contact_Name"];
      this.contact_Email = _data["contact_Email"];
      this.username = _data["username"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
      this.isAdmin = _data["isAdmin"];
    }
  }

  static fromJS(data: any): UpdateAdminRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateAdminRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["id"] = this.id;
    data["business_Name"] = this.business_Name;
    data["mailing_Address_1"] = this.mailing_Address_1;
    data["mailing_Address_2"] = this.mailing_Address_2;
    data["country"] = this.country;
    data["city"] = this.city;
    data["state"] = this.state;
    data["zip"] = this.zip;
    data["contact_Name"] = this.contact_Name;
    data["contact_Email"] = this.contact_Email;
    data["username"] = this.username;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    data["isAdmin"] = this.isAdmin;
    return data;
  }
}

export interface IUpdateAdminRequest {
  id?: number;
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
  isAdmin?: boolean;
}

export class UpdateCurrentUserRequest implements IUpdateCurrentUserRequest {
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;

  constructor(data?: IUpdateCurrentUserRequest) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.business_Name = _data["business_Name"];
      this.mailing_Address_1 = _data["mailing_Address_1"];
      this.mailing_Address_2 = _data["mailing_Address_2"];
      this.country = _data["country"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.zip = _data["zip"];
      this.contact_Name = _data["contact_Name"];
      this.contact_Email = _data["contact_Email"];
      this.username = _data["username"];
      this.password = _data["password"];
      this.confirmPassword = _data["confirmPassword"];
    }
  }

  static fromJS(data: any): UpdateCurrentUserRequest {
    data = typeof data === "object" ? data : {};
    let result = new UpdateCurrentUserRequest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    data["business_Name"] = this.business_Name;
    data["mailing_Address_1"] = this.mailing_Address_1;
    data["mailing_Address_2"] = this.mailing_Address_2;
    data["country"] = this.country;
    data["city"] = this.city;
    data["state"] = this.state;
    data["zip"] = this.zip;
    data["contact_Name"] = this.contact_Name;
    data["contact_Email"] = this.contact_Email;
    data["username"] = this.username;
    data["password"] = this.password;
    data["confirmPassword"] = this.confirmPassword;
    return data;
  }
}

export interface IUpdateCurrentUserRequest {
  business_Name?: string | undefined;
  mailing_Address_1?: string | undefined;
  mailing_Address_2?: string | undefined;
  country?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zip?: string | undefined;
  contact_Name?: string | undefined;
  contact_Email?: string | undefined;
  username?: string | undefined;
  password?: string | undefined;
  confirmPassword?: string | undefined;
}

export class ZipCodeResponse implements IZipCodeResponse {
  addresses?: string[] | undefined;

  constructor(data?: IZipCodeResponse) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property)) (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      if (Array.isArray(_data["addresses"])) {
        this.addresses = [] as any;
        for (let item of _data["addresses"]) this.addresses!.push(item);
      }
    }
  }

  static fromJS(data: any): ZipCodeResponse {
    data = typeof data === "object" ? data : {};
    let result = new ZipCodeResponse();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === "object" ? data : {};
    if (Array.isArray(this.addresses)) {
      data["addresses"] = [];
      for (let item of this.addresses) data["addresses"].push(item);
    }
    return data;
  }
}

export interface IZipCodeResponse {
  addresses?: string[] | undefined;
}

export class ApiException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any };
  result: any;

  constructor(
    message: string,
    status: number,
    response: string,
    headers: { [key: string]: any },
    result: any
  ) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(
  message: string,
  status: number,
  response: string,
  headers: { [key: string]: any },
  result?: any
): any {
  if (result !== null && result !== undefined) throw result;
  else throw new ApiException(message, status, response, headers, null);
}

function isAxiosError(obj: any | undefined): obj is AxiosError {
  return obj && obj.isAxiosError === true;
}
